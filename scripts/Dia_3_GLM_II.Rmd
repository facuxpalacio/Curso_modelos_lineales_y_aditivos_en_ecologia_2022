---
title: "Dia 3. GLM II"
author: 'Autor: Facundo X. Palacio'
date: "`r Sys.Date()`"
output: 
  tufte::tufte_html:
    toc: true
---

\

## Modelos truncados en cero
Santos et al. (2011) estudiaron la probabilidad de persistencia de las carcasas de animales muertos en ruta (Snakes.txt). La variable respuesta es la cantidad de dias que perduraban las carcasas sin ser removidas (N_days). Las variables explicatorias son el tamaño de cada especie (Size_cm), la proporcion de dias con lluvia (PDayRain), las precipitaciones totales (Tot_Rain), la temperatura diaria promedio (Temp_avg), la identidad de la ruta que representa la intesidad del trafico (Road; EN114 tiene alto transito, EN4 tiene trafico medio, y EN370_EN114_4 tiene bajo trafico), la ubicación en la ruta (Road_Loc; L = asfalto, V = borde), la estacion (Season), y la especie (Species).

```{r explo6}
# Analisis exploratorio
serp <- read.table("C:/RD/Snakes.txt", header = T) 
str(serp)
plot(table(serp$N_days))
mean(serp$N_days)
pairs(serp[, c("PDayRain", "Tot_Rain", "Temp_avg")])
round(cor(serp[, c("PDayRain", "Tot_Rain", "Temp_avg")]), 2)
boxplot(serp$PDayRain ~ serp$Season)
boxplot(serp$Tot_Rain ~ serp$Season)
boxplot(serp$Temp_avg ~ serp$Season)
```
\

### GLM Poisson

```{r glm poisson 2}
m.pois <- glm(N_days ~ Size_cm + PDayRain + Tot_Rain + Road + Size_cm + Road_Loc + Size_cm:PDayRain, family = poisson, data = serp)
summary(m.pois)
```

\

### GLM Poisson truncado en cero
```{r glm poisson truncado}
library(VGAM)
m.pois.trun <- vglm(N_days ~ Size_cm + PDayRain + Tot_Rain + Road + Size_cm + Road_Loc + Size_cm:PDayRain, family = pospoisson, control =  vglm.control(maxit = 100), data = serp)
summary(m.pois.trun)
```

\

### GLM binomial negativo truncado en cero
```{r glm BN truncado}
m.nb.trun <- vglm(N_days ~ Size_cm + PDayRain + Tot_Rain + Road + Size_cm + Road_Loc + Size_cm:PDayRain, family = posnegbinomial, control =  vglm.control(maxit = 100), data = serp)
summary(m.nb.trun)
```

\

### Comparacion de coeficientes entre modelos
```{r coef GLM}
data.frame(coef.Poisson = summary(m.pois)$coeff[, 1], 
           coef.Poisson.truncado = summary(m.pois.trun)@coef3[, 1])
```

\

## Modelos inflados en ceros
Hemmingsen et al. (2005) analizaron las infecciones por *Trypanosoma* en bacalaos (*Gadus morhua*) durante cruceros anuales en la costa norte de Noruega. La variable respuesta es la prevalencia de parasitos (Prevalence). Posibles variables explicatorias son el año (Year), area (Area) y profundidad de captura (Depth). 

```{r explo7}
# Analisis exploratorio
parasitos <- read.table("C:/RD/ParasiteCod.txt", header = T) 
str(parasitos)
plot(table(parasitos$Intensity))
table(parasitos$Intensity)[1] # Numero de ceros observados

# Ajuste de distribucion a los datos
xIntensity <- mean(parasitos$Intensity, na.rm = TRUE)
sim.pois <- dpois(x = 0:max(parasitos$Intensity, na.rm = TRUE), lambda = xIntensity)
ndatos <- length(na.omit(parasitos$Intensity))
random.sample.pois <- rpois(n = ndatos, lambda = xIntensity)
plot(table(random.sample.pois))
dpois(x = 0, lambda = xIntensity) # Probabilidad de observar un cero
table(random.sample.pois) # Numero de ceros esperados
```

\

### Modelos de 2 partes o "valla" (ZAP y ZANB)
```{r ZAP y ZANB}
# La primera parte de la formula contiene las covariables para el proceso de conteo, la segunda parte contiene las covariables para la probabilidad de los falsos ceros.
ZAP <- hurdle(Intensity ~ Depth | Length + Depth, dist = "poisson", 
link = "logit", data = parasitos)
summary(ZAP)

ZANB <- hurdle(Intensity ~ Depth | Length + Depth, dist = "negbin", 
link = "logit", data = parasitos)
summary(ZANB)
```

\

### Comparacion de ZAP y ZANB
```{r ZAP vs ZANB}
lrtest(ZAP, ZANB) # Test de razon de verosimilitud
AIC(ZAP, ZANB)
```

\

### Validacion
```{r validacion ZANB}
resid <- residuals(ZANB, type = "pearson")
plot(resid, predict(ZANB), xlab = "Residuos", ylab = "Predichos")
```

\

### Interpretacion y graficos del modelo
```{r graficos ZANB}
# Proceso de falsos ceros
Depth <- seq(min(parasitos$Depth), max(parasitos$Depth), length = 500)
Length <- mean(parasitos$Length, na.rm = TRUE)
zero.model.coef <- ZANB$coefficients$zero # Coeficientes
u <- zero.model.coef[1] + Length*zero.model.coef[2] + Depth*zero.model.coef[3]
zero.model.pred <- exp(u)/(1 + exp(u)) # Predicciones
parasitos$ceros <- ifelse(parasitos$Intensity == 0, 0, 1) # Ceros vs no ceros
plot(parasitos$Depth, parasitos$ceros, pch = 19, xlab = "Profundidad", ylab = "Probabilidad de obtener un cero")
lines(Depth, zero.model.pred, col = "blue", lwd = 2.5, main = "ZANB")

# Proceso de conteo
count.model.coef <- ZANB$coefficients$count # Coeficientes
u <- count.model.coef[1] + Depth*count.model.coef[2]
count.model.pred <- exp(u) # Predicciones
plot(parasitos$Depth, parasitos$Intensity, pch = 19, xlab = "Profundidad", ylab = "Prevalencia")
lines(Depth, count.model.pred, col = "blue", lwd = 2)
```

\

### GLMs de mezcla (ZIP y ZINB)
```{r glm inflado}
library(pscl)
# La primera parte de la formula contiene las covariables para el proceso de conteo, la segunda parte contiene las covariables para la probabilidad de los falsos ceros.
ZIP <- zeroinfl(Intensity ~ Depth | Length + Depth, dist = "poisson", 
link = "logit", data = parasitos)
summary(ZIP)

ZINB <- zeroinfl(Intensity ~ Depth | Length + Depth, dist = "negbin", 
link = "logit", data = parasitos)
summary(ZINB)
```

\

### Comparacion de ZIP y ZINB
```{r ZIP vs ZINB}
library(lmtest)
lrtest(ZIP, ZINB) # Test de razon de verosimilitud
```

\

### Validacion
```{r validacion ZINB}
resid <- residuals(ZINB, type = "pearson")
plot(resid, predict(ZINB), xlab = "Residuos", ylab = "Predichos")
AIC(ZIP, ZINB)
```

\

### Interpretacion y graficos del modelo
```{r graficos ZINB}
# Proceso de falsos ceros
Depth <- seq(min(parasitos$Depth), max(parasitos$Depth), length = 500)
Length <- mean(parasitos$Length, na.rm = TRUE)
zero.model.coef <- ZINB$coefficients$zero # Coeficientes
u <- zero.model.coef[1] + Length*zero.model.coef[2] + Depth*zero.model.coef[3]
zero.model.pred <- exp(u)/(1 + exp(u)) # Predicciones
plot(Depth, zero.model.pred, col = "blue", type = "l", lwd = 3, xlab = "Profundidad", ylab = "Probabilidad de falso cero")

# Proceso de conteo
count.model.coef <- ZINB$coefficients$count # Coeficientes
u <- count.model.coef[1] + Depth*count.model.coef[2]
count.model.pred <- exp(u) # Predicciones
plot(Depth, count.model.pred, col = "blue", type = "l", lwd = 3, xlab = "Profundidad", ylab = "Numero de parasitos")
```

\

### INFERENCIA MULTIMODELO
Cabral et al. (2007) estudiaron la distribución de platijas (*Solea solea*) en el estuario Tagus, Portugal. Se desea saber qué factores están relacionados con la presencia esta especie.
```{r explo8}
# Analisis exploratorio
datos <- read.table("C:/RD/Solea.txt", header = TRUE)
str(datos)
round(cor(datos[, 4:12]), 2)
```

#### Modelos candidatos
```{r}
# modelo nulo
m1 <- glm(Solea_solea ~ 1, family = binomial, data = datos)
# modelo de temperatura
m2 <- glm(Solea_solea ~ temperature, family = binomial, data = datos)
# modelo de salinidad
m3 <- glm(Solea_solea ~ salinity, family = binomial, data = datos)
# modelo de transparencia
m4 <- glm(Solea_solea ~ transparency, family = binomial, data = datos)
# modelo de profundidad
m5 <- glm(Solea_solea ~ depth, family = binomial, data = datos)
# modelo caracteristicas del agua
m6 <- glm(Solea_solea ~ temperature + salinity + transparency, family = binomial, data = datos)
# Modelo ubicacion en el espacio
m7 <- glm(Solea_solea ~ Area + depth + Area:depth, family = binomial, data = datos)
# Modelo de caracteristicas del sutrato
m8 <- glm(Solea_solea ~ gravel + large_sand + med_fine_sand, family = binomial, data = datos)
# Modelo de caracteristicas del sustrato grueso
m9 <- glm(Solea_solea ~ gravel + large_sand, family = binomial, data = datos)
# Modelo de caracteristicas del sustrato fino
m10 <- glm(Solea_solea ~ med_fine_sand, family = binomial, data = datos)
# Modelo de profundidad y sustrato
m11 <- glm(Solea_solea ~ depth + gravel + large_sand + med_fine_sand, family = binomial, data = datos)
```

\

### Seleccion de modelos
```{r}
library(MuMIn)
modelos <- list(m1, m2, m3, m4, m5, m6, m7, m8, m9, m10, m11)
ranking.modelos <- model.sel(modelos, rank = "AICc")
ranking.modelos
plot(1:length(modelos), ranking.modelos$delta, pch = 19, xlab = "Modelo", ylab = expression(Delta ~ "AICc"))
abline(a = 2, b = 0, lty = 2)
```

\

### Promediado de modelos
```{r}
modelo.promedio <- model.avg(ranking.modelos, subset = delta < 2)
summary(modelo.promedio)
importance(modelo.promedio)
```eter was added to the code chunk to prevent printing of the R code that generated the plot.
